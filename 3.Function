인상깊은 문장
  1. 작게 만들어라
    첫 번째 규칙은 '작게'이고, 두 번째 규칙은 '더 작게'이다.
    근거를 제시하기는 어려우나 코드의 줄수는 적을수록 좋고, 함수도 많은 기능을 수행하도록 크게 만드는 것은 지양해야한다
    if/else문, while문 등에 들어가는 블록은 한 줄이어야 한다는 의미이다.
    중첩구조가 생길만큼 함수가 커져서는 안 된다.

    - 한 가지만 해라
      = 함수는 한 가지를 해야한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.
      지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다.
      그러나 단순히 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 작업은 여러개를 하는 셈이다.

  2. 함수당 추상화 수준은 하나로
    - 함수가 확실히 '한 가지' 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다.
    - 한 함수 내에 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다. 특정 표현이 근본 개념인지 아니면 세부사항인지 구분하기 어렵기 때문이다.
    - 근본 개념과 세부사항을 뒤섞기 시작하면 깨어진 창문처럼 사람들이 함수에 세부사항을 추가한다.

    내려가기 규칙
      코드가 위에서 아래로 이야기처럼 읽혀야 좋은 것이다.

    - 추상화 수준이 하나인 함수를 만들기는 참 어렵다. 그러나 핵심은 짧으면서도 '한 가지'만 하는 함수이다.

  3. Switch문
    Switch문은 작게 만들기 어렵다. 본질적으로 switch문은 N가지를 처리하기에 '한 가지' 작업만 하는 switch문도 만들기 어렵다.

  4. 서술적인 이름을 사용하지마라
    - 한 가지만 하는 작은 함수에 좋은 이름을 붙인다면 앞서 말한 원칙(깨끗한 코드 - 좋은 이름)을 달성함에 있어 절반은 성공이다.
    - 길고 서술적인 이름이 길고 서술적인 주석보다 좋다.
    - 함수의 기능을 잘 표현하는 이름을 선택해야 한다.
    - 서술적인 이름을 사용하면 개발자 머릿속에서도 설계가 뚜렷해지므로 코드를 개선하기 쉬워진다.
    - 이름을 붙일 때는 일관성이 있어야 한다. 모듈 내에서 함수 이름이 같은 문구, 명사, 동사를 사용해야 한다.
      ex) includeSetupAndTearDownPages, includeSetupPages, includeSuiteSetupPage, includeSetupPage 등

  함수 인수
    - 함수에서 이상적인 인수의 갯수는 0개이다. 다음으로 1개(단항), 그 다음으로는 2개(이항), 3개(삼항)은 가능한 피하는게 좋고, 4개(다항)는 특별한 이유가 필요하지만,
      특별한 이유가 있어도 사용하지 말아야 한다.
    - 인수가 두개인 경우 하나의 인수를 무시하는 경향이 발생, 이는 결국 문제를 일으키게 된다(어떤 코드든 절대로 무시하면 안된다. 무시한 코드에 오류가 숨어드는 법이다).
    
    - 단항 함수. 함수 인수 1개를 넘기는 이유
      1. 인수에 질문을 던지는 경우
        ex) boolean fileExists('Myfile') 이 가장 좋은 예다.
      2. 인수를 뭔가로 변환해 결과를 반환하는 경우
        ex) inputStream fileOpen('Myfile') string 형식의 파일 이름은 inputStream으로 변환
    - 드물게 사용하지만 아주 유용한 단항 함수 형식인 이벤트 (이벤트 라는 사실이 코드에 명확히 드러나야 한다 - 이름과 문맥을 주의해서 선택)
      ex) passwordAttemptFailedNtimes(int attempts) 비밀번호를 몇번 틀렸는지 알 수 있다
    - 플래그 인수는 웬만하면 사용하지 않는다. 함수로 boolean 값을 넘기는 것은 대놓고 함수가 한번에 여러 가지를 처리한다고 공표하는 것이다.
      플래그를 넘기는 것이 아니라 처리하는 기능을 한가지씩 가진 함수를 만드는 것이 좋다
    
    - 이항 함수. 인수가 두 개인 함수는 한 개인 함수보다 이해하기 어렵다.
      1. 인수가 두 개 라면 코드의 맥락을 파악해야 하는 시간이 필요하고, 둘 중 하나의 인수를 무시하게 되면 결국 문제가 발생한다.
      2. 이항 함수가 적절한 경우
        ex) Point p - new Point(0,0) 직교 좌표계 점은 일반적으로 인수 2개를 취하기 때문이다.
    
    - 삼항 함수.
      1. 삼항 함수는 이항 함수보다 훨씬 더 이해하기 어렵다. 순서나 인수를 봤을 때 주춤하거나(시간), 무시함으로 야기되는 문제가 두 배 이상 증가한다.
      2. 인수가 많이 필요한 함수 정의가 필요하다면 따로 클래스 변수 선언 가능성을 고려해보기

  부수효과를 일으키지 마라
    - 함수명에서 드러나지 않는 행위는 개발자를 위험하게 한다.
    - 시간적인 결합 말하자면, 특정상황에서만 해당 함수를 호출할 수 있게 된다.
  
  예외를 사용하라
    - 요류코드를 함수에서 반환하면 여러단계로 중첩되는 코드를 야기한다.
    - 예외를 사용하면 오류처리코드가 원래 코드에서 분리되므로 코드가 깔끔해진다 (try-catch, 그러나 try-catch도 깔끔하게 써야한다 (58p 참조하기)) 
  
  중복은 소프트웨어의 모든 악의 근원이다

  모든 함수와 함수 내 모든 블록에 입구와 출구가 하나만 존재해야한다. (loop 안에서 continue나 break는 절대 안됨)

  처음부터 함수를 앞에서 말한것처럼 짤 수는 없다. 길고 복잡하기 때문이다. 들여쓰기 단계도 많고 중복된 루프도 많다. 인수가 많은건 말 할 필요도 없고, 이름은 즉흥적이고 코드는 중복된다.
  하지만 코드를 빠짐없이 테스트하는 단위테스트 케이스를 만든다. 그렇게 코드를 다듬고, 함수를 만들고, 이름을 바꾸고, 중복을 제거한다.
  메서드를 줄이고 순서를 바꾼다. 전체 클래스를 쪼개기도 한다. 그러나 코드는 모든 단위테스트를 통과해야한다
    - 단위테스트는 정말 중요하다

  감상
    - 개발을 시작하면서 단위테스트라는 것이 중요하다는 말을 점점 많이 듣고 있고, 실제로 현업에서도 그 중요성을 계속해서 이야기하는 개발자들이 많다.
    - 그러나 아직까지 이 단위테스트에 대한 인사이트가 부족해서일까 감을 잡지 못하겠다.또한, 여태까지 내가 했던 프로젝트들의 코드를 돌이켜보면 그저 돌아
      가는 것에만 치중된 함수만 만들었던것 같다. 나름 생각하고 짰던 코드지만 완전 하드코딩이었던 것 같다.
    - 이번 함수편을 읽으면서 전반적으로 내용을 이해하기에 시간이 많이 필요했다. 많은 시간을 쏟았지만 사실 아직 소화하지 못한 느낌이다. 이부분은 계속해서 읽어야겠다.

    